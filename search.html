<!DOCTYPE html>
<html>
<head>
  <title>Story Stapler - Search</title>
  <link rel="icon" type="image/png" href="static/assets/staple.png">
  <script src="static/js/p5/p5.js"></script>
  <link rel="stylesheet" href="static/css/fonts.css">
  <link rel="stylesheet" href="static/css/search.css">
</head>
<body>
<button class="returnBtn" type="button" onclick="window.location.href='index.html'"></button>
<button id="reloadScenesBtn"></button>
<button id="helpBtn"></button>
<input 
  type="text" 
  id="titleInput" 
  placeholder="Enter your title" 
  style="margin: 10px 0; display: block;" 
/>
<button class="stitchBtn" id="stitchBtn" onclick="stitchVideo()"></button>
<div id="searchFormsContainer">
  <div id="formsWrapper">
  </div>
  <button id="newFormBtn" onclick="addSearchForm()">
    <img id="btnImg" src="static/assets/addBtn.svg" alt="Add Search Form" height="60px" width="60px"/>
  </button>
</div>
<div id="stitchPopup">
  <div id="stitchContent">
    <p id="stitchStatus">Waiting for stitching...</p>
    <div id="p5-canvas-container" style="width:896px; height:504px;"></div>
    <button id="closeStitchPopup" class="deletePopup" style="display:none" onclick="document.getElementById('stitchPopup').style.display='none';"></button>
    <video id="stitchedVideo" controls style="max-width: 90%; display: none;"></video>
    <button id="saveVideoBtn" style="display:none;" onclick="saveStitchedVideo()">Save Video</button>
  </div>
</div>
<div id="helpPopup" style="display:none;">
  <div id="helpContent">
    <button id="closeHelpPopup" class="deletePopup" onclick="document.getElementById('helpPopup').style.display='none';"></button>
    <p>
      Welcome to the CREATE page! <br>
      <br>
      Here you can search for scenes from movies and TV shows to create your own video story.<br>
      Use the Search bar to find actions, emotions, or specific moments.<br>
      <br>
      Use the slider to balance between dialogue and description in your search.<br>
      Dialogue focuses on spoken words, while description captures visual elements and actions.<br>
      <br>
      You can use the "Create Filter" button to add filters like genre, year, emotion, and location to refine your search.<br>
      After finding scenes, click on them to view details and add them to your queue.<br>
      <br>
      Use the reload button to refresh the scene database if you think new content is available.<br>
      <br>
      Use the "+" button to add more scenes.<br>
      <br>
      Finally, add a title and staple all your scenes together into a final film.<br>
      Have Fun!

    </p>
  </div>
</div>
<script type="module">

  let sceneImageUrls = [];  // Populate this from your queued scene data
  let sceneImages = [];
  let p5Instance = null;
  
  const mockFilters = {
    genres: ["Action","Adventure","Biography", "Comedy", "Crime", "Drama","Documentary", "Fantasy", "Horror","Mystery", "Musical", "Romance", "SciFi","Sitcom","Sports","Superhero","Supenatural","Thriller","War","Western"],
    years: [1990, 1995, 2000, 2005, 2010, 2015, 2020],
    emotions: ["happy", "sad", "angry", "fearful"],
    locations: ["New York", "London", "Tokyo", "Mars"]
  };
  const mockResults = [
  { type: "movie", title: "12 Angry Men", genres: ["Drama"] },
  { type: "movie", title: "2001: A Space Odessey", genres: ["SciFi", "Adventure"] },
  { type: "movie", title: "A Fistful of Dollars", genres: ["Western", "Action"] },
  { type: "movie", title: "A Gaiola Dourada", genres: ["Comedy"] },
  { type: "movie", title: "Akira", genres: ["SciFi", "Action"] },
  { type: "movie", title: "Alice in Wonderland", genres: ["Fantasy"] },
  { type: "movie", title: "Alien", genres: ["SciFi", "Horror"] },
  { type: "movie", title: "American Beauty", genres: ["Drama"] },
  { type: "movie", title: "American Psycho", genres: ["Thriller", "Crime"] },
  { type: "show", series: "Arcane", season: 1, episode: 1, title: "Everybody Wants to be My Enemy", genres: ["Fantasy", "Action"] },
  { type: "movie", title: "Arrival", genres: ["SciFi", "Drama"] },
  { type: "movie", title: "Avatar", genres: ["SciFi", "Adventure"] },
  { type: "show", series: "Avatar the Last Airbender", season: 2, episode: 15, title: "Tales of Ba Sing Se", genres: ["Fantasy", "Adventure"] },
  { type: "movie", title: "Avengers: Endgame", genres: ["Action", "Superhero"] },
  { type: "movie", title: "Avengers: Infinity War", genres: ["Action", "Superhero"] },
  { type: "movie", title: "Baby Driver", genres: ["Action", "Crime"] },
  { type: "movie", title: "Back to the Future", genres: ["SciFi", "Adventure"] },
  { type: "movie", title: "Bambi", genres: ["Drama"] },
  { type: "movie", title: "Barbie", genres: ["Comedy", "Fantasy"] },
  { type: "movie", title: "Bee Movie", genres: ["Comedy"] },
  { type: "movie", title: "Before Midnight", genres: ["Romance", "Drama"] },
  { type: "movie", title: "Before Sunrise", genres: ["Romance", "Drama"] },
  { type: "movie", title: "Before Sunset", genres: ["Romance", "Drama"] },
  { type: "movie", title: "Blade Runner", genres: ["SciFi", "Thriller"] },
  { type: "show", series: "Blue Planet II", season: 1, episode: 1, title: "One Ocean", genres: ["Documentary"] },
  { type: "show", series: "Bojack Horseman", season: 6, episode: 15, title: "The View From Halfway Down", genres: ["Comedy", "Drama"] },
  { type: "movie", title: "Braveheart", genres: ["Drama", "War"] },
  { type: "show", series: "Breaking Bad", season: 5, episode: 7, title: "Say My Name", genres: ["Crime", "Drama"] },
  { type: "show", series: "Brooklyn 99", season: 3, episode: 10, title: "Yippie Kayak", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "Captain America: Civil War", genres: ["Action", "Superhero"] },
  { type: "movie", title: "Cars", genres: ["Comedy"] },
  { type: "movie", title: "Casablanca", genres: ["Romance", "Drama"] },
  { type: "movie", title: "Casino Royal", genres: ["Action", "Thriller"] },
  { type: "show", series: "Cheers", season: 5, episode: 9, title: "Dinner at Eight-ish", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "Cidade de Deus", genres: ["Crime", "Drama"] },
  { type: "movie", title: "Cinema Paradiso", genres: ["Drama"] },
  { type: "movie", title: "CitzenKane", genres: ["Drama"] },
  { type: "movie", title: "Clockwork Orange", genres: ["Crime", "Thriller"] },
  { type: "show", series: "Community", season: 5, episode: 4, title: "Cooperative Polygraphy", genres: ["Sitcom", "Comedy"] },
  { type: "show", series: "Cosmos", season: 1, episode: 1, title: "Journeys in Space and Time", genres: ["Documentary"] },
  { type: "show", series: "Cowboy Bebop", season: 1, episode: 1, title: "Asteroid Blues", genres: ["SciFi", "Action"] },
  { type: "show", series: "Daredevil: Born Again", season: 1, episode: 1, title: "Heaven's Last Hour", genres: ["Action", "Superhero"] },
  { type: "movie", title: "David Attenborough: A Life On Our Planet", genres: ["Documentary"] },
  { type: "movie", title: "Dead Poets Society", genres: ["Drama"] },
  { type: "movie", title: "Deadpool & Wolverine", genres: ["Action", "Superhero"] },
  { type: "movie", title: "Despicable Me", genres: ["Comedy"] },
  { type: "movie", title: "DieHard", genres: ["Action", "Thriller"] },
  { type: "movie", title: "Dirty Dancing", genres: ["Romance"] },
  { type: "movie", title: "Django: Unchained", genres: ["Western", "Drama"] },
  { type: "movie", title: "Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb", genres: ["Comedy", "War"] },
  { type: "movie", title: "Dune: Part One", genres: ["SciFi", "Adventure"] },
  { type: "movie", title: "E.T. The Extra-Terrestrial", genres: ["SciFi", "Adventure"] },
  { type: "movie", title: "Eternal Sunshine of the Spotless Mind", genres: ["Romance", "Drama"] },
  { type: "movie", title: "Everything, Everywhere All At Once", genres: ["SciFi", "Adventure"] },
  { type: "show", series: "Family Guy", season: 4, episode: 1, title: "PTV", genres: ["Sitcom", "Comedy"] },
  { type: "show", series: "Family Guy", season: 6, episode: 1, title: "Blue Harvest", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "Fight Club", genres: ["Drama", "Thriller"] },
  { type: "movie", title: "For a Few Dollars More", genres: ["Western", "Action"] },
  { type: "movie", title: "Forest Gump", genres: ["Drama", "Romance"] },
  { type: "show", series: "Friends", season: 5, episode: 14, title: "The One Where Everyone Finds Out", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "Frozen", genres: ["Musical", "Fantasy"] },
  { type: "movie", title: "Full Metal Jacket", genres: ["War", "Drama"] },
  { type: "show", series: "Game of Thrones", season: 6, episode: 9, title: "Battle of the Bastards", genres: ["Fantasy", "Drama"] },
  { type: "show", series: "Game of Thrones", season: 3, episode: 9, title: "The Rains of Castamere", genres: ["Fantasy", "Drama"] },
  { type: "movie", title: "Glass Onion: A Knives Out Mystery", genres: ["Mystery", "Comedy"] },
  { type: "movie", title: "Godzilla Minus One", genres: ["SciFi", "Action"] },
  { type: "movie", title: "Good Morning Vietnam", genres: ["War", "Comedy"] },
  { type: "movie", title: "Good Will Hunting", genres: ["Drama", "Romance"] },
  { type: "show", series: "Gravity Falls", season: 2, episode: 11, title: "Not What He Seems", genres: ["Fantasy", "Mystery"] },
  { type: "show", series: "Gravity Falls", season: 2, episode: 10, title: "Northwest Mansion Mystery", genres: ["Fantasy", "Mystery"] },
  { type: "movie", title: "Halloween", genres: ["Horror"] },
  { type: "movie", title: "Harry Potter and the Chamber of Secrets", genres: ["Fantasy"] },
  { type: "movie", title: "Harry Potter and the Prisoner of Azkaban", genres: ["Fantasy"] },
  { type: "movie", title: "Harry Potter and the Sorceror's Stone", genres: ["Fantasy"] },
  { type: "movie", title: "Home Alone", genres: ["Comedy"] },
  { type: "show", series: "How I Met Your Mother", season: 9, episode: 16, title: "How Your Mother Met Me", genres: ["Sitcom", "Comedy"] },
  { type: "show", series: "How I Met Your Mother", season: 5, episode: 8, title: "The Playbook", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "How the Grinch Stole Christmas", genres: ["Comedy", "Fantasy"] },
  { type: "movie", title: "How to Train Your Dragon", genres: ["Fantasy", "Adventure"] },
  { type: "movie", title: "How To Train Your Dragon 2", genres: ["Fantasy", "Adventure"] },
  { type: "movie", title: "Indiana Jones And The Raiders of the Lost Ark", genres: ["Adventure"] },
  { type: "movie", title: "Inglorious Bastards", genres: ["War", "Drama"] },
  { type: "movie", title: "Interstellar", genres: ["SciFi", "Adventure"] },
  { type: "movie", title: "It", genres: ["Horror"] },
  { type: "movie", title: "It's a Wonderful Life", genres: ["Drama", "Romance"] },
  { type: "show", series: "It's Always Sunny in Philadelphia", season: 12, episode: 6, title: "Hero or Hate Crime", genres: ["Sitcom", "Comedy"] },
  { type: "show", series: "It's Always Sunny in Philadelphia", season: 11, episode: 5, title: "Mac & Dennis Move to the Suburbs", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "Jackass The Movie", genres: ["Comedy"] },
  { type: "movie", title: "Jaws", genres: ["Thriller"] },
  { type: "movie", title: "John Wick", genres: ["Action", "Thriller"] },
  { type: "movie", title: "Jurassic Park", genres: ["SciFi", "Adventure"] },
  { type: "movie", title: "Kill Bill Vol.1", genres: ["Action"] },
  { type: "movie", title: "Kizumonogatari I: Tekketsu", genres: ["Fantasy"] },
  { type: "movie", title: "Kizumonogatari II: Nekketsu-hen", genres: ["Fantasy"] },
  { type: "movie", title: "Kizumonogatari III: Reiketsu-hen", genres: ["Fantasy"] },
  { type: "movie", title: "Knives Out", genres: ["Mystery"] },
  { type: "movie", title: "KPop Demon Hunters", genres: ["Fantasy", "Supernatural"] },
  { type: "movie", title: "La La Land", genres: ["Musical", "Romance"] },
  { type: "movie", title: "La vita è bella", genres: ["Drama", "War"] },
  { type: "movie", title: "Lawrence of Arabia", genres: ["Adventure", "Drama"] },
  { type: "movie", title: "Lord of the Rings: Fellowship of the Ring", genres: ["Fantasy", "Adventure"] },
  { type: "movie", title: "Lord of the Rings: Return of the King", genres: ["Fantasy", "Adventure"] },
  { type: "movie", title: "Lord of the Rings: The Two Towers", genres: ["Fantasy", "Adventure"] },
  { type: "movie", title: "Madagascar", genres: ["Comedy"] },
  { type: "movie", title: "Mary Poppins", genres: ["Musical", "Fantasy"] },
  { type: "movie", title: "Memento", genres: ["Thriller"] },
  { type: "movie", title: "Men In Black", genres: ["SciFi", "Comedy"] },
  { type: "movie", title: "Million Dollar Baby", genres: ["Drama", "Sports"] },
  { type: "show", series: "Modern Family", season: 9, episode: 1, title: "Lake Life", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "Modern Times", genres: ["Comedy"] },
  { type: "movie", title: "Once Upon a Time in the West", genres: ["Western"] },
  { type: "movie", title: "Oppenheimer", genres: ["Biography", "Drama"] },
  { type: "movie", title: "Palm Springs", genres: ["Comedy", "SciFi"] },
  { type: "movie", title: "Parasite", genres: ["Drama", "Thriller"] },
  { type: "show", series: "Parks and Recreation", season: 3, episode: 2, title: "Flu Season", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "Pirates of the Caribbean: The Curse of the Black Pearl", genres: ["Adventure", "Fantasy"] },
  { type: "movie", title: "Pride and Prejudice", genres: ["Romance", "Drama"] },
  { type: "movie", title: "Psycho", genres: ["Horror", "Thriller"] },
  { type: "movie", title: "Pulp Fiction", genres: ["Crime", "Thriller"] },
  { type: "movie", title: "Ratatouille", genres: ["Comedy"] },
  { type: "movie", title: "Rocky", genres: ["Sports", "Drama"] },
  { type: "movie", title: "Saving Private Ryan", genres: ["War", "Drama"] },
  { type: "movie", title: "Saw I", genres: ["Horror", "Thriller"] },
  { type: "movie", title: "Schindler's List", genres: ["Biography", "Drama"] },
  { type: "movie", title: "Scott Pilgrim Vs The World", genres: ["Comedy", "Action"] },
  { type: "movie", title: "Se7en", genres: ["Thriller", "Crime"] },
  { type: "show", series: "Seinfeld", season: 4, episode: 11, title: "The Contest", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "Seven Samurai", genres: ["Action", "Drama"] },
  { type: "show", series: "Severance", season: 1, episode: 1, title: "Good News About Hell", genres: ["Mystery", "Drama"] },
  { type: "show", series: "Severance", season: 1, episode: 2, title: "Hello Ms. Cobel", genres: ["Mystery", "Drama"] },
  { type: "movie", title: "Shrek", genres: ["Comedy", "Fantasy"] },
  { type: "movie", title: "Shrek 2", genres: ["Comedy", "Fantasy"] },
  { type: "movie", title: "Silence of the Lambs", genres: ["Thriller", "Crime"] },
  { type: "movie", title: "Singin' in the Rain", genres: ["Musical", "Romance"] },
  { type: "movie", title: "Sinners", genres: ["Drama"] },
  { type: "movie", title: "Slumdog Millionaire", genres: ["Drama", "Romance"] },
  { type: "movie", title: "Sonic the hedgehog 3", genres: ["Action", "Adventure"] },
  { type: "show", series: "South Park", season: 11, episode: 1, title: "With Apologies to Jesse Jackson", genres: ["Sitcom", "Comedy"] },
  { type: "show", series: "South Park", season: 7, episode: 12, title: "Sermon on the Mount", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "Speed", genres: ["Action", "Thriller"] },
  { type: "movie", title: "Spider-man", genres: ["Action", "Superhero"] },
  { type: "movie", title: "Spider-man 2", genres: ["Action", "Superhero"] },
  { type: "movie", title: "Spider-man 3", genres: ["Action", "Superhero"] },
  { type: "movie", title: "Spider-man: Homecoming", genres: ["Action", "Superhero"] },
  { type: "movie", title: "Spider-man: Into the Spiderverse", genres: ["Action", "Superhero"] },
  { type: "movie", title: "Spider-Man: No Way Home", genres: ["Action", "Superhero"] },
  { type: "movie", title: "Spirited Away", genres: ["Fantasy", "Adventure"] },
  { type: "movie", title: "Star Wars Episode IV - A New Hope", genres: ["SciFi", "Adventure"] },
  { type: "movie", title: "Star Wars Episode VI - Return of the Jedi", genres: ["SciFi", "Adventure"] },
  { type: "movie", title: "Star Wars Episode V - The Empire Strikes Back", genres: ["SciFi", "Adventure"] },
  { type: "show", series: "Stranger Things", season: 1, episode: 8, title: "The Upside Down", genres: ["Fantasy", "Supernatural"] },
  { type: "movie", title: "Superbad", genres: ["Comedy"] },
  { type: "movie", title: "Superman", genres: ["Action", "Superhero"] },
  { type: "show", series: "Ted Lasso", season: 1, episode: 10, title: "The Hope That Kills You", genres: ["Sports", "Comedy"] },
  { type: "movie", title: "Terminator 2: Judgement Day", genres: ["Action", "SciFi"] },
  { type: "movie", title: "The Batman", genres: ["Action", "Superhero"] },
  { type: "show", series: "The Bear", season: 1, episode: 7, title: "System", genres: ["Drama"] },
  { type: "show", series: "The Big Bang Theory", season: 2, episode: 11, title: "The Bathroom Gift Hypothesis", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "The Breakfast Club", genres: ["Drama"] },
  { type: "movie", title: "The Bugs Bunny / Road Runner Movie", genres: ["Comedy"] },
  { type: "movie", title: "The Dark Knight", genres: ["Action", "Superhero"] },
  { type: "movie", title: "The Devil Wears Prada", genres: ["Comedy", "Drama"] },
  { type: "movie", title: "The Exorcist", genres: ["Horror"] },
  { type: "movie", title: "The Fault in Our Stars", genres: ["Romance", "Drama"] },
  { type: "movie", title: "The Godfather", genres: ["Crime", "Drama"] },
  { type: "movie", title: "The Good, The Bad and The Ugly", genres: ["Western"] },
  { type: "movie", title: "The Grand Budapest Hotel", genres: ["Comedy"] },
  { type: "movie", title: "The Green Book", genres: ["Biography", "Drama"] },
  { type: "movie", title: "The Incredibles", genres: ["Action", "Superhero"] },
  { type: "movie", title: "The Karate Kid", genres: ["Sports", "Drama"] },
  { type: "movie", title: "The Lion King", genres: ["Musical", "Drama"] },
  { type: "movie", title: "The Matrix", genres: ["SciFi", "Action"] },
  { type: "movie", title: "The Naked Gun: From the Files of the Police Squad", genres: ["Comedy"] },
  { type: "movie", title: "The Nightmare Before Christmas", genres: ["Fantasy", "Musical"] },
  { type: "show", series: "The Office UK", season: 1, episode: 1, title: "Downsize", genres: ["Sitcom", "Comedy"] },
  { type: "show", series: "The Office US", season: 5, episode: 14, title: "Stress Relief", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "The Shawshank Redemption", genres: ["Drama"] },
  { type: "movie", title: "The Shining", genres: ["Horror", "Thriller"] },
  { type: "show", series: "The Simpsons", season: 6, episode: 25, title: "Who Killed Mr. Burns (1)", genres: ["Sitcom", "Comedy"] },
  { type: "show", series: "The Simpsons", season: 7, episode: 1, title: "Who Killed Mr. Burns (2)", genres: ["Sitcom", "Comedy"] },
  { type: "movie", title: "The Sixth Sense", genres: ["Thriller", "Supernatural"] },
  { type: "movie", title: "The Social Network", genres: ["Drama", "Biography"] },
  { type: "movie", title: "The Sound of Music", genres: ["Musical", "Romance"] },
  { type: "movie", title: "The Sting", genres: ["Crime"] },
  { type: "movie", title: "The Terminator", genres: ["Action", "SciFi"] },
  { type: "movie", title: "The Thing", genres: ["Horror", "SciFi"] },
  { type: "movie", title: "The Truman Show", genres: ["Drama", "Comedy"] },
  { type: "movie", title: "The Wizard of Oz", genres: ["Fantasy", "Musical"] },
  { type: "movie", title: "Titanic", genres: ["Romance", "Drama"] },
  { type: "show", series: "Twin Peaks", season: 1, episode: 1, title: "Northwest Passage", genres: ["Mystery", "Drama"] },
  { type: "movie", title: "Unforgiven", genres: ["Western"] },
  { type: "movie", title: "Vertigo", genres: ["Mystery", "Thriller"] },
  { type: "movie", title: "Wall - E", genres: ["SciFi", "Romance"] },
  { type: "movie", title: "Wallace & Gromit: The Curse of the Were Rabbit", genres: ["Comedy"] },
  { type: "movie", title: "Whiplash", genres: ["Drama", "Music"] },
  { type: "movie", title: "Willy Wonka & The Chocolate Factory", genres: ["Fantasy", "Musical"] },
  { type: "movie", title: "Wolf of Wall Street", genres: ["Biography", "Crime"] },
  { type: "movie", title: "Your Name.", genres: ["Romance", "Fantasy"] }
];


function fakeFetch(url, options = {}) {
  if (url.includes("/filters")) {
    return Promise.resolve({ ok: true, json: () => Promise.resolve(mockFilters) });
  }
  if (url.includes("/search")) {
    return Promise.resolve({ ok: true, json: () => Promise.resolve(mockResults) });
  }
  if (url.includes("/queue")) {
    return Promise.resolve({ ok: true, json: () => Promise.resolve({ success: true }) });
  }
  if (url.includes("/stitch")) {
    return Promise.resolve({ 
      ok: true, 
      json: () => Promise.resolve({
        success: true, 
        video_path: "https://sample-videos.com/video123/mp4/720/big_buck_bunny_720p_1mb.mp4"
      }) 
    });
  }
  if (url.includes("/reload_scenes")) {
    return Promise.resolve({ ok: true, json: () => Promise.resolve({ success: true }) });
  }
  return fetch(url, options); // fallback for other requests
}

  let sketch = (p) => {
    p.setMoveThreshold(0);
    let imgPos = [];
    let framePos = [];
    let staplerX = [];
    let step;
    let timer;
    let imgW, imgH;
    let timerStart = 60;
    let stop = false;
    let spacing;
    let imgHeights = [];

    p.preload = () => {
      sceneImages = sceneImageUrls.map(url => p.loadImage(url));
    };

    p.setup = () => {
      p.createCanvas(896, 504);
      imgW = p.width / 4;
      imgH = (p.height * 9) / 16;
      imgHeights = sceneImages.map(img => (img.height / img.width) * p.width/3);
      step = 7;

      staplerX[0] = -600;
      staplerX[1] = -400;

      spacing = imgW;
      timer = timerStart;

      for (let i = 1; i < 18; i += 2) {
        let x = i * p.width / 16;
        framePos.push(x);
      }

      for (let i = 0; i < sceneImages.length; i++) {
        imgPos.push(p.width + i * (imgW + spacing));
      }
    };

    p.draw = () => {
      p.background(255);
      p.rectMode(p.CENTER);

      p.fill(p.color('#2b2b2b'));
      p.rect(p.width / 2, p.height / 2, p.width, 300);

      for (let i = 0; i < imgPos.length; i++) {
        const img = sceneImages[i % sceneImages.length];
        if (img) {
          p.imageMode(p.CENTER);
          p.image(img, imgPos[i], p.height / 2, p.width/3, imgHeights[i % imgHeights.length]);
        }

        if (!stop) {
          imgPos[i] -= step;
          if (imgPos[i] < -imgW / 2) {
            let maxX = Math.max(...imgPos);
            imgPos[i] = maxX + imgW + spacing;
          }
        }
      }

      for (let i = 0; i < imgPos.length; i++) {
        if (imgPos[i] + imgW / 2 + spacing / 2 === p.width / 2) {
          stop = true;
        }
      }

      p.fill(255);
      for (let j = 0; j < framePos.length; j++) {
        p.rect(framePos[j], 1 * p.height / 5+35, 60, 25, 7);
        p.rect(framePos[j], 4 * p.height / 5-35, 60, 25, 7);
        if (!stop) {
          framePos[j] -= step;
          if (framePos[j] <= -p.width / 16) {
            framePos[j] = 17 * p.width / 16;
          }
        }
      }

      p.fill(200);
      p.rect(staplerX[0], p.height / 2, p.width / 8, 15, 5);
      p.rect(staplerX[1], p.height / 2, p.width / 8, 15, 5);

      if (!stop) {
        staplerX[0] -= step;
        staplerX[1] -= step;
      }

      if (stop) {
        timer--;
        if (timer === timerStart / 2) {
          let minStap = staplerX.indexOf(Math.min(...staplerX));
          staplerX[minStap] = p.width / 2;
        } else if (timer === 0) {
          timer = timerStart;
          stop = false;
        }
      }
    };
  };


  const btn = document.getElementById('newFormBtn');
  const img = document.getElementById('btnImg');
  const defaultSrc = 'static/assets/addBtn.svg';
  const hoverSrc = 'static/assets/addBtn.hover.svg';

  btn.addEventListener('mouseenter', () => {
    if (!btn.disabled) {
      img.src = hoverSrc;
    }
  });

  btn.addEventListener('mouseleave', () => {
    if (!btn.disabled) {
      img.src = defaultSrc;
    }
  });

  const genreColorMap = {
    action: '#e88828',
    adventure: '#e88828',
    biography: '#26875f',
    comedy: '#d0e223',
    crime: '#3b97e2',
    documentary:'#26875f',
    drama: '#3b97e2',
    fantasy: '#c640dd',
    horror: '#4040a8',
    musical: '#d83a7b',
    mystery: '#3b97e2',
    romance: '#d83a7b',
    scifi: '#c640dd',
    sitcom: '#d0e223',
    sports: '#d83a7b',
    superhero: '#c13030',
    supernatural: '#c640dd',
    thriller: '#4040a8',
    war: '#26875f',
    western: '#c13030',
  };
  const genreColorMapHover = {
    action: '#b26520',
    adventure: '#b26520',
    biography: '#185137',
    comedy: '#a6ad1c',
    crime: '#2f7aad',
    documentary:'#185137',
    drama: '#2f7aad',
    fantasy: '#9433a8',
    horror: '#2d2d72',
    musical: '#a32e63',
    mystery: '#2f7aad',
    romance: '#a32e63',
    scifi: '#9433a8',
    sitcom: '#a6ad1c',
    sports: '#a32e63',
    superhero: '#8c2525',
    supernatural: '#9433a8',
    thriller: '#2d2d72',
    war: '#185137',
    western: '#8c2525',
  };

  let NextFormId = 2;let windowMargin = 10;

document.addEventListener("click", (e) => {
  if (e.target.classList.contains("edit-scene-btn")) {
    const wrapper = e.target.closest(".sceneDisplay").parentElement;
    const formId = wrapper.id.replace("-wrapper", "");
    const sceneId = wrapper.dataset.sceneId;
    const startSec = parseFloat(wrapper.dataset.start_time);
    const endSec = parseFloat(wrapper.dataset.end_time);

    // Rebuild scene object — you might want to save more data to wrapper.dataset if needed
    const scene = {
      scene_id: sceneId,
      title: window.currentSceneTitle,  // you may need a map if you queue multiple scenes
      segment: [secondsToTime(startSec), secondsToTime(endSec)],
      moviecode: extractMovieCodeFromSceneId(sceneId), // You'll define this helper
      total_scenes: 1,  // or look it up
      type: "movie",  // or save type in dataset
      desc: "",       // optionally preload description
      dialogue: "",   // optionally preload dialogue
      score: 0,       // optionally preload score
    };

    openScenePopup(scene, formId);
  }
});


function extractMovieCodeFromSceneId(sceneId) {
  return sceneId.split(".json")[0];
}

export function initSegmentModal() {
  if (document.getElementById("sceneModal")) return; // Prevent duplicates

  const modalHTML = `
    <div id="sceneModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.8); z-index:1000;">
      <div id="modalContent">
        <span style="position:absolute; top:10px; right:15px; cursor:pointer; font-size:24px;" onclick="closeScenePopup()">&times;</span>
        <div id="modalInnerContent"></div>
      </div>
    </div>
  `;
  document.body.insertAdjacentHTML("beforeend", modalHTML);
  window.closeScenePopup = closeScenePopup; // expose for inline click

  // Close modal when clicking outside modal content
  document.getElementById("sceneModal").addEventListener("click", (e) => {
    if (e.target.id === "sceneModal") {
      closeScenePopup();
    }
  });
}


export function openScenePopup(scene,formId) {
  console.log("Scene data received:", scene);
  window.currentFormId = formId;
  window.currentSceneTitle = scene.title;
  window.currentSceneId = scene.scene_id;
  const {
    title="Whatever the Movie Is Called",
    scene_id="748",
    moviecode="some_movie",
    total_scenes="4911235",
    segment=["00:00:00", "00:01:00"],
    type="movie",
    desc="Something interesting happens. There's a thing, and then another thing. Lots of stuff is on screen. People are talking. It's  quite engaging. A guy is doing something important here.",
    dialogue="I did it! We did it! This is amazing! Can you believe it? Wow, just wow.",
    location = ["somewhere", "here", "there", "everywhere", "nowhere"],
    emotion = { happy: "happy", sad: "sad", angry: "Angry", surprised: "surprised" , neutral: "neutral"},
    season = "",
    episode = "",
    series = "",
    year = "2025",
    score = 0.748,
  } = scene;
  const [start, end] = segment;
  const sceneIdParsed = scene_id.replace(`${moviecode}.json - Scene `, "").trim();



  const modal = document.getElementById("sceneModal");
  const content = document.getElementById("modalInnerContent");

  const videoPath = `././movies/${moviecode}/movie.mp4`;
  const startSec = timeToSeconds(start);
  const endSec = timeToSeconds(end);

  if (isNaN(startSec) || isNaN(endSec)) {
    console.error("Invalid segment times:", start, end);
    alert("This scene has invalid time format and cannot be previewed.");
    return;
  }

  // Format locations
  const locationList = location.length
    ? location.map(loc => `<li>${loc.charAt(0).toUpperCase()}${loc.slice(1)}</li>`).join("")
    : "<li>None</li>";


  // Format emotion scores
  const emotionList = Object.values(emotion)
    .map(em =>{ const str = String(em);  // ensures it's a string
    return `<li>${str.charAt(0).toUpperCase()}${str.slice(1)}</li>`;
    })
    .join("") || "<li>None</li>";
  const seriesInfo =
    type === "series"
      ? `
    <p><span class="seriesTitle"> ${series}</span> — <span class="season">Season ${season}</span><span class="episode"> Episode ${episode}</span></p>
  `
      : "";


  content.innerHTML = `
    <div class="info-header">
      ${seriesInfo}
      <h3>${title} <span class="year">(${year})</span></h3>
      <p><span class="idScore"> <strong>Scene:</strong> ${sceneIdParsed}/${total_scenes}<strong>    Score:</strong> ${score.toFixed(3)}</span></p>
    </div>
    
    <div class="midSection">
      <div class="videoContainer">
        <video id="video" width="640" height="360" preload="metadata">
          <source src="././movies/${moviecode}/movie.mp4" type="video/mp4" />
          <track src="././movies/${moviecode}/subtitles.vtt" kind="subtitles" srclang="en" label="English" default />
          Your browser does not support HTML5 video.
        </video>
      </div>

      <div class="info">
        <p><strong>Segment:</strong> ${start} – ${end}</p>
        <br>
        <p><strong>Description:</strong> ${desc}</p>
        <br>
        <p><strong>Dialogue:</strong> ${dialogue}</p>
        <br>
        <div class="locEmo">
          <div class="locations">
            <p><strong>Locations:</strong></p>
            <ul>${locationList}</ul>
          </div>
          <div class="emotions">
            <p><strong>Emotions:</strong></p>
            <ul>${emotionList}</ul>
          </div>
        </div>
      </div>
    </div>

    <div class="control-panel">
      <button class="paused" id="playPause"></button>
      <div class="slider-container" id="slider">
        <div class="range-bar" id="rangeBar"></div>
        <div class="handle" id="startHandle"></div>
        <div class="handle" id="endHandle"></div>
        <div class="playhead" id="playhead"></div>
      </div>
      <div class="time-display">
        <span id="startTime">${start}</span> |
        <span id="endTime">${end}</span>
      </div>
    </div>

    <!-- Queue button disabled -->
    <button class="queueBtn" disabled style="opacity:0.5; cursor:not-allowed;">
      Queue Scene (disabled in testing mode)
    </button>
  `;

  window.segment = { start: startSec, end: endSec };
  setupPopupPlayer();
  window.currentSceneId = scene_id;
  modal.style.display = "block";
}



function closeScenePopup() {
  const modal = document.getElementById("sceneModal");
  const content = document.getElementById("modalInnerContent");

  // Pause video and remove source to clear cache
  const video = content.querySelector("video");
  if (video) {
    video.pause();
    // Remove sources and reload video to release cache
    while (video.firstChild) {
      video.removeChild(video.firstChild);
    }
    video.load();
  }

  // Clear modal content and hide modal
  content.innerHTML = '';
  modal.style.display = "none";
}

function setupPopupPlayer() {
  const video = document.getElementById("video");
  const slider = document.getElementById("slider");
  const rangeBar = document.getElementById("rangeBar");
  const startHandle = document.getElementById("startHandle");
  const endHandle = document.getElementById("endHandle");
  const playhead = document.getElementById("playhead");
  const playPauseBtn = document.getElementById("playPause");
  const startTimeLabel = document.getElementById("startTime");
  const endTimeLabel = document.getElementById("endTime");

  let sliderWidth;
  let duration = 0;
  let windowStart, windowEnd, windowDuration;

  function timeToX(time) {
    return ((time - windowStart) / windowDuration) * sliderWidth;
  }

  function xToTime(x) {
    return windowStart + (x / sliderWidth) * windowDuration;
  }

  function updateHandles() {
    const startX = timeToX(window.segment.start);
    const endX = timeToX(window.segment.end);

    startHandle.style.left = `${startX}px`;
    endHandle.style.left = `${endX}px`;
    rangeBar.style.left = `${startX}px`;
    rangeBar.style.width = `${endX - startX}px`;

    startTimeLabel.textContent = `${secondsToTime(window.segment.start)}`;
    endTimeLabel.textContent = `${secondsToTime(window.segment.end)}`;
    updatePlayhead();
  }

  function updatePlayhead() {
    const currentX = timeToX(video.currentTime);
    playhead.style.left = `${currentX}px`;
  }

  function makeDraggable(handle, isStart) {
    let dragging = false;

    handle.addEventListener("mousedown", (e) => {
      dragging = true;
      e.preventDefault();
    });

    window.addEventListener("mousemove", (e) => {
      if (!dragging) return;
      const rect = slider.getBoundingClientRect();
      let x = e.clientX - rect.left;
      x = Math.max(0, Math.min(x, slider.offsetWidth));
      const time = xToTime(x);

      if (isStart) {
        window.segment.start = Math.min(time, window.segment.end - 1);
        video.currentTime = window.segment.start;
      } else {
        window.segment.end = Math.max(time, window.segment.start + 1);
      }
      updateHandles();
    });

    window.addEventListener("mouseup", () => dragging = false);
  }

  video.addEventListener("loadedmetadata", () => {
    duration = video.duration;
    sliderWidth = slider.offsetWidth;
    windowStart = Math.max(0, window.segment.start - windowMargin);
    windowEnd = Math.min(duration, window.segment.end + windowMargin);
    windowDuration = windowEnd - windowStart;

    updateHandles();
    video.currentTime = window.segment.start;
    updatePlayhead();
  });

  video.addEventListener("timeupdate", () => {
    if (video.currentTime > window.segment.end) {
      video.pause();
      playPauseBtn.classList.remove("playing");
      playPauseBtn.classList.add("paused");
    }
    updatePlayhead();
  });

  playPauseBtn.addEventListener("click", () => {
    if (video.paused) {
      // If we're at or past the segment end, restart at segment start
      if (video.currentTime >= window.segment.end) {
        video.currentTime = window.segment.start;
      }
      video.play();
      playPauseBtn.classList.add("playing");
      playPauseBtn.classList.remove("paused");
    } else {
      video.pause();
      playPauseBtn.classList.remove("playing");
      playPauseBtn.classList.add("paused");
    }
  });

  makeDraggable(startHandle, true);
  makeDraggable(endHandle, false);

  slider.addEventListener("click", (e) => {
    const rect = slider.getBoundingClientRect();
    let x = e.clientX - rect.left;
    x = Math.max(0, Math.min(x, slider.offsetWidth));
    const clickedTime = xToTime(x);
    video.currentTime = Math.max(window.segment.start, Math.min(clickedTime, window.segment.end));
    updatePlayhead();
  });
}

function timeToSeconds(t) {
  const [h, m, s] = t.split(":").map(Number);
  return h * 3600 + m * 60 + s;
}

function secondsToTime(sec) {
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = Math.floor(sec % 60);
  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
}

function replaceFormWithQueueMessage(formId, sceneTitle, thumbnails = []) {
  const wrapper = document.getElementById(`${formId}-wrapper`);
  if (!wrapper) return;

  let thumbsHTML = "";
  if (thumbnails.length) {
    thumbsHTML = `
      <div class="segment-thumbnails">
        ${thumbnails.map((src, idx) => `<img src="${src}" alt="Frame ${idx + 1}" width="280" />`).join("")}
      </div>
    `;
  }

  wrapper.innerHTML = `
    <div class="sceneDisplay">
      <p>${sceneTitle}</p>
      <button class="removeBtn" type="button" onclick="removeQueuedScene('${formId}', '${window.currentSceneId}')"></button>
      ${thumbsHTML}
      <button class="edit-scene-btn">Edit</button>
    </div>
  `;
}

window.removeQueuedScene = function(formId, sceneId) {
  // Remove from queuedScenes array
  const index = queuedScenes.indexOf(sceneId);
  if (index > -1) {
    queuedScenes.splice(index, 1);
  }

  // Optionally notify the server if needed
  fetch('/unqueue', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ scene_id: sceneId })
  }).catch(err => {
    console.warn("Failed to notify server about unqueue:", err);
  });

  // Remove the wrapper from DOM
  const wrapper = document.getElementById(`${formId}-wrapper`);
  if (wrapper) wrapper.remove();

  // Optionally update stitch button state if needed
  const stitchBtn = document.getElementById(`${formId}-stitchBtn`);
  if (stitchBtn) stitchBtn.disabled = true;

  updateStatus(`Queued ${queuedScenes.length}/5 scenes.`, formId);
};


export function restoreSearchForm(formId) {
  const wrapper = document.getElementById(`${formId}-wrapper`);
  if (!wrapper) return;

  // Remove old wrapper (to reset event handlers etc)
  wrapper.remove();

  // Re-add a new search form with the same formId
  // Note: your addSearchForm() currently auto increments and creates new ids,
  // so let's make a helper to recreate a form with a given formId.

  createSearchFormWithId(formId);
}

window.logSegment = function(formId, sceneTitle) {
  console.log(`Selected segment: ${secondsToTime(window.segment.start)} - ${secondsToTime(window.segment.end)}`);

  const sceneId = window.currentSceneId;
  const wrapper = document.getElementById(`${formId}-wrapper`);
  wrapper.classList.add('queued');
  wrapper.dataset.sceneId = sceneId;
  wrapper.dataset.start_time = window.segment.start;
  wrapper.dataset.end_time = window.segment.end;

  const video = document.getElementById("video");
  const start = window.segment.start;
  const end = window.segment.end;
  const mid = start + (end - start) / 2;

  const captureFrameAt = (time) => {
    return new Promise((resolve) => {
      video.currentTime = time;
      const handler = () => {
        const canvas = document.createElement("canvas");
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        video.removeEventListener("seeked", handler);
        resolve(canvas.toDataURL("image/jpeg"));
      };
      video.addEventListener("seeked", handler);
    });
  };

  const captureAndDisplay = async () => {
    try {
      const segmentLength = end - start;
      const timestamps = [
        start,
        start + 0.25 * segmentLength,
        start + 0.75 * segmentLength,
        end
      ];

      const frames = [];

      for (const time of timestamps) {
        const frame = await captureFrameAt(time);
        frames.push(frame);
      }

      closeScenePopup();
      replaceFormWithQueueMessage(formId, sceneTitle, frames);
    } catch (err) {
      console.error("Frame capture failed:", err);
      closeScenePopup();
      replaceFormWithQueueMessage(formId, sceneTitle);
    }
  };



  captureAndDisplay();
};


window.onSegmentQueued = function(sceneId, formId = null) {
  if (!queuedScenes.includes(sceneId)) {
    queuedScenes.push(sceneId);
    updateStatus(`Queued ${queuedScenes.length}/5 scenes.`, formId);
    if (formId) {
      const stitchBtn = document.getElementById(`${formId}-stitchBtn`);
      if (stitchBtn) {
        stitchBtn.disabled = false;
      }
    } else {
      // fallback if no formId
      const stitchBtn = document.getElementById('stitchBtn');
      if (stitchBtn) stitchBtn.disabled = false;
    }
  }
};
  
  initSegmentModal();
  window.openScenePopup = openScenePopup;
  window.handleSceneClick = handleSceneClick;
  window.addSearchForm = addSearchForm;
  window.showFilterOptions = showFilterOptions;
  window.removeForm = removeForm;
  window.removeFilter = removeFilter;
  window.queueScene = queueScene;
  window.stitchVideo = stitchVideo;
  window.restoreSearchForm = restoreSearchForm;
  let formCounter = 0;
  window.queuedScenes = [];
  let genreOptions = [];
  let yearOptions = [1990, 1995, 2000, 2005, 2010, 2015, 2020];
  let emotionOptions = [];
  let locationOptions = [];
  const originalFormHTML = {};

  document.addEventListener("DOMContentLoaded", async () => {
    const response = await fetch("/filters");
    const filters = await response.json();
    genreOptions = filters.genres;
    yearOptions = filters.years;
    emotionOptions = filters.emotions;
    locationOptions = filters.locations;

    // Initialize the first search bar
    addSearchForm();    
  });

  function handleSceneClick(el) {
    const sceneData = JSON.parse(decodeURIComponent(el.dataset.scene));
    openScenePopup(sceneData,formID);
  }
  const popupS = document.getElementById('stitchPopup');
  const closeButton = document.getElementById('closeStitchPopup');
  popupS.addEventListener('click', function (event) {
    
    const content = document.getElementById('stitchContent');

    // Only run if popup is currently visible
    if (popupS.style.display !== 'none' && !content.contains(event.target)) {
      popupS.style.display = 'none';
      closeButton.style.display = 'none';
    }
  });



  async function loadFiltersOnce() {
    const resp = await fetch('/filters');
    if (!resp.ok) {
      alert('Failed to load filters');
      return null;
    }
    return await resp.json();
  }

  function getAllFormIds() {
    const wrappers = document.querySelectorAll('#formsWrapper > div[id$="-wrapper"]');
    const formIds = Array.from(wrappers)
      .map(div => div.id.replace('-wrapper', ''))
      .filter(id => id); // ensure no empty strings
    return formIds;
  }

  function addSearchForm() {
    const container = document.getElementById('formsWrapper');

    // Step 1: Get all existing form IDs
    const formIds = getAllFormIds().map(id => parseInt(id)).sort((a, b) => a - b);

    // Step 2: Find the first missing number
    let formId = 1;
    for (let i = 0; i < formIds.length; i++) {
      if (formIds[i] !== i + 1) {
        formId = i + 1;
        break;
      }
      formId = formIds.length + 1;
    }

    // Step 3: Create and insert the new form wrapper
    const wrapper = document.createElement('div');
    wrapper.id = `${formId}-wrapper`;
    wrapper.classList.add('search-form-block', 'form');
    wrapper.setAttribute('draggable', 'true');

    wrapper.innerHTML = `
      <form id="${formId}">
        <h2>New Scene:</h2>
        <button type="button" class="removeBtn" onclick="removeForm('${formId}')"></button>
        <input type="text" placeholder="What are you looking for?" name="query" size="40" autocomplete="off" required />
        <div class="range-group">
          <input type="range" class="dialogueSld" id="weight" name="weight" min="0" max="1" step="0.01" value="0.75" />
          <div class="range-labels">
            <span class="labelD">Dialogue</span>
            <span class="labelD">Description</span>
          </div>
        </div>
        <div id="${formId}-filter-buttons">
          <button type="button" onclick="showFilterOptions('${formId}')" class="filterAddBtn">Create Filter</button>
        </div>
        <div id="${formId}-filters"></div>
        <button type="submit" class="searchBtn">Search</button>
      </form>
      <div id="${formId}-results" class="results-block"></div>
    `;
    container.appendChild(wrapper);

    const form = document.getElementById(formId);
    form.addEventListener('submit', (e) => runSearch(e, formId));
  }

  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('formsWrapper');

    container.addEventListener('pointerdown', (e) => {
      if (e.target.type === 'range') {
        const wrapper = e.target.closest('.search-form-block');
        if (wrapper) {
          wrapper.setAttribute('draggable', 'false');
        }
      }
    });

    container.addEventListener('pointerup', (e) => {
      if (e.target.type === 'range') {
        const wrapper = e.target.closest('.search-form-block');
        if (wrapper) {
          wrapper.setAttribute('draggable', 'true');
        }
      }
    });
  });

  function showFilterOptions(formId) {
    const availableFilters = ['emotion', 'location', 'genre', 'year'];
    const form = document.getElementById(formId);
    const btnContainer = document.getElementById(`${formId}-filter-buttons`);

    // Remove any existing select or add button first to avoid duplicates
    const existingSelect = btnContainer.querySelector('select');
    const existingAddBtn = btnContainer.querySelector('button[type="button"]:not(:first-child)');
    if (existingSelect) existingSelect.remove();
    if (existingAddBtn) existingAddBtn.remove();

    const addedFilters = new Set([...form.querySelectorAll('select')].map(sel => sel.name));

    const yearAdded = addedFilters.has('yearStart') && addedFilters.has('yearEnd');
    if (yearAdded) {
      addedFilters.add('year');
      addedFilters.delete('yearStart');
      addedFilters.delete('yearEnd');
    }

    const remaining = availableFilters.filter(f => !addedFilters.has(f));

    if (remaining.length === 0) {
      alert('All filters added.');
      return;
    }

    // Create new select dropdown with remaining filters
    const menu = document.createElement('select');
    menu.innerHTML = remaining.map(f => `<option value="${f}">${f}</option>`).join('');

    // Create Add button
    const confirmBtn = document.createElement('button');
    confirmBtn.textContent = 'Add';
    confirmBtn.type = 'button';

    confirmBtn.onclick = () => {
      addFilterField(formId, menu.value);
      menu.remove();
      confirmBtn.remove();
    };

    btnContainer.appendChild(menu);
    btnContainer.appendChild(confirmBtn);
  }


  function addFilterField(formId, filterName) {
    const target = document.getElementById(`${formId}-filters`);
    const filterId = `${formId}-${filterName}-filter`;

    if (document.getElementById(filterId)) return; // prevent duplicate filters

    let html = '';
    if (filterName === 'emotion') {
      html = `
        <label class="lineF">Emotion:</label>
        <select name="emotion">
          ${emotionOptions.map(e => `<option value="${e}">${e.charAt(0).toUpperCase() + e.slice(1)}</option>`).join('')}
        </select>
      `;
    } else if (filterName === 'location') {
      html = `
        <label class="lineF">Location:</label>
        <select name="location">
          ${locationOptions.map(l => `<option>${l}</option>`).join('')}
        </select>
      `;
    }  else if (filterName === 'genre') {
        // Normalize, deduplicate, and sort genres
        const normalizedGenres = Array.from(
          new Set(
            genreOptions.map(g => g.trim().toLowerCase())
          )
        ).filter(g => g !== 'all').sort();

        html = `
          <label class="lineF">Genre:</label>
          <select name="genre">
            <option value="All">All</option>
            ${normalizedGenres.map(g => {
              const display = g.charAt(0).toUpperCase() + g.slice(1);
              return `<option value="${display}">${display}</option>`;
            }).join('')}
          </select>
        `;
      } else if (filterName === 'year') {
      html = `
        <label class="lineF">Year Range:</label>
        <select name="yearStart">
          ${yearOptions.map(y => `<option value="${y}">${y}</option>`).join('')}
        </select>
        to
        <select name="yearEnd">
          ${yearOptions.map((y, i) => `<option value="${y}" ${i === yearOptions.length - 1 ? 'selected' : ''}>${y}</option>`).join('')}
        </select>
      `;
    }

    const container = document.createElement('div');
    container.id = filterId;
    container.innerHTML = `
      <div>
        ${html}
        <button type="button" class="removeFil" onclick="removeFilter('${filterId}')"></button>
      </div>
    `;
    target.appendChild(container);
  }

  function removeFilter(filterId) {
    const element = document.getElementById(filterId);
    if (element) element.remove();
  }

  function toggleFormAndResults(formId, showForm) {
    const formWrapper = document.getElementById(`${formId}-wrapper`);
    const form = formWrapper.querySelector('form');
    const resultsDiv = document.getElementById(`${formId}-results`);

    if (showForm) {
      form.style.display = 'block';
      resultsDiv.style.display = 'none';
    } else {
      form.style.display = 'none';
      resultsDiv.style.display = 'block';
    }
  }

  function removeForm(formId) {

    if (formId === 'form0') {
      alert("You cannot remove the first search form.");
      return;
    }

    NextFormId=formId;
    
    const wrapper = document.getElementById(`${formId}-wrapper`);

    if (originalFormHTML[formId]) {
      const match = originalFormHTML[formId].match(/Scene (\w+) added to queue/);
      if (match) {
        const sceneId = match[1];
        const idx = queuedScenes.indexOf(sceneId);
        if (idx !== -1) {
          queuedScenes.splice(idx, 1);  // Remove from queue
          document.getElementById('stitchBtn').disabled = queuedScenes.length === 0;
        }
      }

      delete originalFormHTML[formId];  // Clean up memory
    }

    if (wrapper) wrapper.remove();
  }
  async function runSearch(event, formId) {
    event.preventDefault();
    const form = document.getElementById(formId);
    const wrapper= document.getElementById(formId+ '-wrapper');
    const query = form.query.value.trim();
    const weight = form.weight.value;
    const emotion = form.emotion ? form.emotion.value : 'All';
    const location = form.location ? form.location.value : 'All';
    const genre = form.genre ? form.genre.value : 'All';
    const yearStart = form.yearStart ? form.yearStart.value : yearOptions[0];
    const yearEnd = form.yearEnd ? form.yearEnd.value : yearOptions[yearOptions.length - 1];

    const url = new URL('/search', window.location.origin);
    url.searchParams.append('query', query);
    url.searchParams.append('weight', weight);
    url.searchParams.append('emotion', emotion);
    url.searchParams.append('location', location);
    url.searchParams.append('genre', genre);
    url.searchParams.append('year_start', yearStart);
    url.searchParams.append('year_end', yearEnd);

    const resp = await fetch(url);
    const results = await resp.json();
    displayResults(formId, results);
    return false;
  }

  function normalizeGenre(genre) {
    return genre.toLowerCase().replace(/[^a-z0-9]/g, '');
  }

  function applyGenreColorToSVG(svgElement, genreColor) {
    const elements = svgElement.querySelectorAll('*');

    elements.forEach(el => {
      const fill = window.getComputedStyle(el).fill;
      const stroke = window.getComputedStyle(el).stroke;

      if (fill && fill !== 'rgb(255, 255, 255)' && fill !== '#ffffff' && fill !== 'white') {
        el.style.fill = genreColor;
      }

      if (stroke && stroke !== 'rgb(255, 255, 255)' && stroke !== '#ffffff' && stroke !== 'white') {
        el.style.stroke = genreColor;
      }
    });
  }

  function displayResults(formId, results) {
    const div = document.getElementById(`${formId}-results`);
    div.innerHTML = ''; // Clear any old content

    // Add Back button first
    const backBtn = document.createElement('button');
    backBtn.classList.add('backBtn');
    backBtn.onclick = () => toggleFormAndResults(formId, true);
    div.appendChild(backBtn);

    // Add a line break for spacing
    div.appendChild(document.createElement('br'));

    if (results.length === 0) {
      div.appendChild(document.createElement('p')).textContent = 'No results found.';
    } else {
      results.forEach((r, idx) => {
        const varName = `scene_${formId}_${idx}`;
        window[varName] = r;
        
        console.log(r);
        const rawGenre = r.genres?.[0] || 'unknown';
        const normalizedGenre = normalizeGenre(rawGenre);
        console.log(`Raw genre: ${rawGenre}, Normalized: ${normalizedGenre}`);
        const color = genreColorMap[normalizedGenre] || 'black';
        const colorHover = genreColorMapHover[normalizedGenre] || 'black';
        const svgPath = `static/assets/genres/${normalizedGenre}.svg`;

        const sceneItem = document.createElement('div');
        sceneItem.className = 'scene-item';
        sceneItem.style.backgroundColor = color;
        sceneItem.style.transition = 'background-color 0.3s ease';

        sceneItem.addEventListener('mouseenter', () => {
          sceneItem.style.backgroundColor = colorHover;
        });

        sceneItem.addEventListener('mouseleave', () => {
          sceneItem.style.backgroundColor = color;
        });
        if(r.type=="movie"){
          sceneItem.innerHTML = `
            <a href="#" onclick="openScenePopup(window['${varName}'], '${formId}'); return false;" style=" color: white;">
              <img src="${svgPath}" alt="${rawGenre}" class="genre-icon" />
              <span>${r.title}</span>
            </a>
          `;
        }
        else{
          sceneItem.innerHTML = `
            <a href="#" onclick="openScenePopup(window['${varName}'], '${formId}'); return false;" style=" color: white;">
              <img src="${svgPath}" alt="${rawGenre}" class="genre-icon" />
              <span>${r.series} - Season ${r.season} Episode ${r.episode}</span>
            </a>
          `;
        }
        div.appendChild(sceneItem);
      });
    }

    toggleFormAndResults(formId, false);
  }

  async function queueScene(formId, sceneId) {
    if (queuedScenes.length >= 5) {
      alert('Queue full (max 5 scenes). Please stitch or clear queue.');
      return;
    }

    const resp = await fetch('/queue', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ scene_id: sceneId })
    });
    const data = await resp.json();

    if (resp.ok && data.success) {
      lastQueuedFormId = formId;
      queuedScenes.push(sceneId);
      document.getElementById('stitchBtn').disabled = false;

      const wrapper = document.getElementById(`${formId}-wrapper`);

      // Save original HTML only once
      if (!originalFormHTML[formId]) {
        originalFormHTML[formId] = wrapper.innerHTML;
      }

      // Extract and preserve the remove button
      const removeBtn = wrapper.querySelector('.removeBtn');
      const removeBtnClone = removeBtn.cloneNode(true); // clone to preserve events

      // Replace content but insert the remove button
      wrapper.innerHTML = `
        <div>
          <p>Scene ${sceneId} added to queue.</p>
          <button id="${formId}-replaceBtn">Replace</button>
        </div>
      `;
      wrapper.appendChild(removeBtnClone); // Append the original remove button

      // Re-bind the click handler
      document.getElementById(`${formId}-replaceBtn`).onclick = () => replaceScene(formId, sceneId);
      removeBtnClone.onclick = () => removeForm(formId);

    } else {
      alert('Failed to queue scene: ' + data.message);
    }
  }

  function replaceScene(formId, sceneId) {
    // Remove from queue
    const idx = queuedScenes.indexOf(sceneId);
    if (idx !== -1) {
      queuedScenes.splice(idx, 1);
    }

    // Restore original form HTML
    const wrapper = document.getElementById(`${formId}-wrapper`);
    wrapper.classList.add('form');
    if (originalFormHTML[formId]) {
      wrapper.innerHTML = originalFormHTML[formId];
      wrapper.classList.add('search-form-block');
      wrapper.setAttribute('draggable', 'true');
      


      // Re-attach submit event handler on restored form
      const form = document.getElementById(formId);
      form.addEventListener('submit', (e) => runSearch(e, formId));

      // Remove saved original HTML to avoid stale cache
      delete originalFormHTML[formId];
    }

    document.getElementById('stitchBtn').disabled = queuedScenes.length === 0;
  }

  async function queueAllScenesBeforeStitching() {
    const wrappers = document.querySelectorAll('.queued');
    if (wrappers.length === 0) {
      alert("No scenes in queue.");
      throw new Error("No scenes in queue.");
    }

    if (wrappers.length === 1) {
      alert("Select at least 2 scenes to stitch.");
      throw new Error("Too few scenes to stitch.");
    }

    const sceneImageUrls = [];
    let queue_id = null;

    for (const wrapper of wrappers) {
      const scene_id = wrapper.dataset.sceneId;
      const start_time = parseFloat(wrapper.dataset.start_time);
      const end_time = parseFloat(wrapper.dataset.end_time);

      // Extract <img> inside wrapper
      const firstImg = wrapper.querySelector('img');
      if (firstImg && firstImg.src) {
        sceneImageUrls.push(firstImg.src);
      }

      try {
        // Include queue_id if we already have one
        const body = queue_id
          ? { scene_id, start_time, end_time, queue_id }
          : { scene_id, start_time, end_time };

        const res = await fetch('/queue', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        const text = await res.text();
        console.log("Raw response:", text);

        let data;
        try {
          data = JSON.parse(text);
        } catch (e) {
          console.error("JSON parse error", e);
          throw new Error(`Invalid JSON for scene ${scene_id}`);
        }

        if (!data.success) {
          throw new Error(`Queueing failed for scene ${scene_id}: ${data.message}`);
        }

        // Save queue_id from response (only first time will set it)
        if (!queue_id && data.queue_id) {
          queue_id = data.queue_id;
        }

      } catch (error) {
        console.error("Queue error:", error);
        alert(`Failed to queue scene ${scene_id}. Stitching aborted.`);
        throw error;
      }
    }

    console.log("✅ All scenes queued successfully.");

    // Re-initialize the canvas with the image URLs
    initializeSceneCanvas(sceneImageUrls);

    return queue_id;
  }

  function initializeSceneCanvas(urls) {
    sceneImageUrls = urls;  // This must be global for p5 preload()

    if (p5Instance) {
      p5Instance.remove();
      p5Instance = null;
    }
    p5Instance = new p5(sketch, 'p5-canvas-container');
  }

  async function stitchVideo() {
    try {
      const queue_id = await queueAllScenesBeforeStitching();  // Validate and queue

      // Show the popup UI...
      const popup = document.getElementById('stitchPopup');
      const statusText = document.getElementById('stitchStatus');
      const videoElement = document.getElementById('stitchedVideo');
      const p5CanvasContainer = document.getElementById('p5-canvas-container');
      const closeButton = document.getElementById('closeStitchPopup');
      const saveBtn = document.getElementById('saveVideoBtn');
      const title = document.getElementById("titleInput").value || "My Story";

      statusText.style.display = "block";
      p5CanvasContainer.style.display = 'block';
      statusText.textContent = ' ';
      saveBtn.style.display= 'none';
      videoElement.style.display = 'none';
      popup.style.display = 'flex';
      

      // Send queue_id in POST body
      const response = await fetch('/stitch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ queue_id,title }),
      });

      const text = await response.text();
      console.log("Raw stitch response:", text);

      let data;
      try {
        data = JSON.parse(text);
      } catch (e) {
        console.error("Failed to parse JSON:", e);
        statusText.textContent = "Stitching failed: invalid server response.";
        return;
      }

      if (data.success && data.video_path) {
        statusText.style.display = "none";
        if (p5Instance) {
          p5Instance.remove();
          p5Instance = null;
        }
        p5CanvasContainer.style.display = 'none';
        closeButton.style.display = 'block';
        videoElement.src = data.video_path;
        videoElement.style.display = 'block';
        saveBtn.style.display = 'block';
      } else {
        statusText.textContent = 'Stitching failed: ' + (data.message || 'Unknown error');
      }
    } catch (err) {
      console.error(err);
      alert("Stitching failed.");
    }
  }
  window.saveStitchedVideo = async function() {
    const video = document.getElementById('stitchedVideo');
    if (!video.src) {
      alert('No video to save!');
      return;
    }

    try {
      const response = await fetch(video.src);
      if (!response.ok) throw new Error("Network response was not ok");

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = url;
      a.download = 'stitched_video.mp4';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      window.URL.revokeObjectURL(url);
    } catch (err) {
      console.error("Download failed:", err);
      alert("Failed to save video.");
    }
  }



document.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById('formsWrapper');
  let draggedElement = null;

  container.addEventListener('dragstart', (e) => {
    // If the drag started in a form control, cancel it
    if (e.target.matches('input, textarea, select')) {
      e.preventDefault();
      return;
    }

    // Otherwise allow dragging of the wrapper
    const block = e.target.closest('.search-form-block');
    if (block) {
      draggedElement = block;
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', draggedElement.outerHTML);
      setTimeout(() => { draggedElement.style.display = 'none'; }, 0);
    }
  });

  container.addEventListener('dragover', (e) => {
    e.preventDefault();
    const target = e.target.closest('.search-form-block');
    if (target && target !== draggedElement) {
      const rect = target.getBoundingClientRect();
      const next = (e.clientY - rect.top) > (rect.height / 2); // vertical order
      container.insertBefore(draggedElement, next ? target.nextSibling : target);
    }
  });

  container.addEventListener('drop', (e) => {
    e.preventDefault();
    if (draggedElement) {
      draggedElement.style.display = '';
      draggedElement = null;
    }
  });

  container.addEventListener('dragend', () => {
    if (draggedElement) {
      draggedElement.style.display = '';
      draggedElement = null;
    }
  });
});

document.getElementById('reloadScenesBtn').addEventListener('click', () => {
  console.log('Reloading scenes...');

  document.getElementById('btnImg').src = 'static/assets/addBtn.disable.svg';
  document.querySelectorAll('.removeBtn').forEach(btn => btn.disabled = true);
  document.getElementById('newFormBtn').disabled = true;
  document.getElementById('reloadScenesBtn').disabled = true;
  document.getElementById('stitchBtn').disabled = true;
  document.querySelectorAll('.searchBtn').forEach(btn => btn.disabled = true);
  document.querySelectorAll('.returnBtn').forEach(btn => btn.disabled = true);

  fetch('/reload_scenes', { method: 'POST' })
    .then(res => res.json())
    .then(data => {
      console.log('Scenes reloaded:', data);
      
      document.getElementById('btnImg').src = 'static/assets/addBtn.svg';
      document.getElementById('newFormBtn').disabled = false;
      document.querySelectorAll('.removeBtn').forEach(btn => btn.disabled = false);
      document.getElementById('reloadScenesBtn').disabled = false;
      document.getElementById('stitchBtn').disabled = false;
      document.querySelectorAll('.searchBtn').forEach(btn => btn.disabled = false);
      document.querySelectorAll('.returnBtn').forEach(btn => btn.disabled = false);
    })
    .catch(err => {
      console.log('Error reloading scenes.');
      console.error(err);

      document.querySelectorAll('.removeBtn').forEach(btn => btn.disabled = false);
      document.getElementById('btnImg').src = 'static/assets/addBtn.svg';
      document.getElementById('newFormBtn').disabled = false;
      document.getElementById('reloadScenesBtn').disabled = false;
      document.getElementById('stitchBtn').disabled = false;
      document.querySelectorAll('.searchBtn').forEach(btn => btn.disabled = false);
      document.querySelectorAll('.returnBtn').forEach(btn => btn.disabled = false);
    });
});

const helpBtn = document.getElementById('helpBtn');
const helpPopup = document.getElementById('helpPopup');
const closeHelpPopup = document.getElementById('closeHelpPopup');

helpBtn.addEventListener('click', () => {
  helpPopup.style.display = 'flex';
});

// Close popup if clicking outside content
helpPopup.addEventListener('click', function (event) {
  const content = document.getElementById('helpContent');
  if (!content.contains(event.target)) {
    helpPopup.style.display = 'none';
  }
});

window.fetch = async function(url, options) {
  url=String(url);
  function shuffleArray(array) {
    const arr = array.slice(); // make a copy
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
    if (url.endsWith("/filters")) {
      return { ok: true, json: async () => mockFilters };
    }
    if (url.includes("/search")) {
      // return mock search results
      const shuffledResults = shuffleArray(mockResults);
      return { ok: true, json: async () => shuffledResults};
    }
    if (url.includes("/queue") || url.includes("/stitch") || url.includes("/reload_scenes")) {
      return { ok: true, json: async () => ({ success: true, video_path: "https://sample-videos.com/video123/mp4/720/big_buck_bunny_720p_1mb.mp4" }) };
    }
    // fallback
    return fetch(url, options);
  };
</script>
</body>
